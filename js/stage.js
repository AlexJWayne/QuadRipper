// Generated by CoffeeScript 1.3.3
(function() {
  var __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  window.Stage = (function() {
    var level;

    Stage.prototype.levels = (function() {
      var _i, _len, _ref, _results;
      _ref = Level.levels;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        level = _ref[_i];
        if (level) {
          _results.push(level);
        }
      }
      return _results;
    })();

    function Stage() {
      this.onKeyUp = __bind(this.onKeyUp, this);

      this.onKeyDown = __bind(this.onKeyDown, this);

      this.onMouseMove = __bind(this.onMouseMove, this);

      var gun, type, _ref;
      this.bindEvents();
      this.createLevelMesh();
      this.crosshair = new Crosshair;
      this.mesh.add(this.crosshair);
      this.guns = Gun.create();
      _ref = this.guns;
      for (type in _ref) {
        gun = _ref[type];
        this.mesh.add(gun);
      }
      this.bullets = [];
      this.enemies = [];
      this.health = 100;
      this.nextLevel();
    }

    Stage.prototype.createLevelMesh = function() {
      var floor, wall, _i, _len, _ref, _results;
      this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(0, 0), new THREE.MeshBasicMaterial());
      scene.add(this.mesh);
      floor = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshPhongMaterial({
        color: 0xdddddd
      }));
      floor.position.z = -2.5;
      this.mesh.add(floor);
      this.walls = [new Wall('top'), new Wall('right'), new Wall('bottom'), new Wall('left')];
      _ref = this.walls;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        wall = _ref[_i];
        _results.push(this.mesh.add(wall));
      }
      return _results;
    };

    Stage.prototype.bindEvents = function() {
      return $(document.body).on('mousemove', this.onMouseMove).on('keydown', this.onKeyDown).on('keyup', this.onKeyUp);
    };

    Stage.prototype.onMouseMove = function(e) {
      var gun, pointerPos, type, _ref, _results;
      pointerPos = scene.camera.screenToWorld('xy', e.clientX, e.clientY);
      this.crosshair.updatePosition(pointerPos);
      _ref = this.guns;
      _results = [];
      for (type in _ref) {
        gun = _ref[type];
        _results.push(gun.updatePosition(pointerPos));
      }
      return _results;
    };

    Stage.prototype.keycodeToPosition = function(code) {
      switch (code) {
        case 87:
          return 'bottom';
        case 68:
          return 'left';
        case 83:
          return 'top';
        case 65:
          return 'right';
      }
    };

    Stage.prototype.onKeyDown = function(e) {
      var gun, position, type, _ref;
      if (this.health <= 0) {
        return;
      }
      position = this.keycodeToPosition(e.which);
      if (!position) {
        return;
      }
      _ref = this.guns;
      for (type in _ref) {
        gun = _ref[type];
        gun.setActive(type === position);
      }
      return false;
    };

    Stage.prototype.onKeyUp = function(e) {
      var _ref;
      if ((_ref = this.guns[this.keycodeToPosition(e.which)]) != null) {
        _ref.setActive(false);
      }
      return false;
    };

    Stage.prototype.update = function() {
      var bullet, enemy, gun, type, wall, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _results,
        _this = this;
      this.updateTiming();
      this.crosshair.update();
      _ref = this.guns;
      for (type in _ref) {
        gun = _ref[type];
        gun.update();
      }
      _ref1 = this.bullets;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        bullet = _ref1[_i];
        bullet.update();
        if (bullet.expired) {
          this.mesh.remove(bullet);
        }
      }
      this.bullets = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = this.bullets;
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
          bullet = _ref2[_j];
          if (!bullet.expired) {
            _results.push(bullet);
          }
        }
        return _results;
      }).call(this);
      _ref2 = this.enemies;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        enemy = _ref2[_j];
        enemy.update();
        if (enemy.expired) {
          this.mesh.remove(enemy);
        }
      }
      this.enemies = (function() {
        var _k, _len2, _ref3, _results;
        _ref3 = this.enemies;
        _results = [];
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          enemy = _ref3[_k];
          if (!enemy.expired) {
            _results.push(enemy);
          }
        }
        return _results;
      }).call(this);
      if (this.showHit) {
        this.showHit = false;
        _ref3 = this.walls;
        for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
          wall = _ref3[_k];
          wall.material.color = new THREE.Color(0xffffff);
        }
      } else {
        _ref4 = this.walls;
        for (_l = 0, _len3 = _ref4.length; _l < _len3; _l++) {
          wall = _ref4[_l];
          wall.material.color = new THREE.Color(0xaaaaaa);
        }
      }
      if (this.health <= 0) {
        _ref5 = this.walls;
        _results = [];
        for (_m = 0, _len4 = _ref5.length; _m < _len4; _m++) {
          wall = _ref5[_m];
          _results.push(wall.material.color = new THREE.Color(0xff0000));
        }
        return _results;
      } else if (this.level.completed()) {
        _ref6 = this.walls;
        for (_n = 0, _len5 = _ref6.length; _n < _len5; _n++) {
          wall = _ref6[_n];
          wall.material.color = new THREE.Color(0x00ff00);
        }
        if (!this.completed) {
          this.completed = true;
          return setTimeout((function() {
            return _this.nextLevel();
          }), 5000);
        }
      }
    };

    Stage.prototype.updateTiming = function() {
      this.thisFrameAt || (this.thisFrameAt = Date.now() / 1000 - 1 / 60);
      this.lastFrameAt = this.thisFrameAt;
      this.thisFrameAt = Date.now() / 1000;
      return this.delta = this.thisFrameAt - this.lastFrameAt;
    };

    Stage.prototype.hit = function(enemy) {
      var _this = this;
      this.health -= 10;
      this.showHit = true;
      if (this.health === 0) {
        return setTimeout((function() {
          return _this.reset();
        }), 5000);
      }
    };

    Stage.prototype.reset = function() {
      var enemy, _i, _len, _ref, _ref1;
      _ref = this.enemies;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        enemy = _ref[_i];
        enemy.expired = true;
      }
      this.health = 100;
      if ((_ref1 = this.level) != null) {
        _ref1.kill();
      }
      this.level = new this.levels[this.levelIndex];
      return this.level.start();
    };

    Stage.prototype.nextLevel = function() {
      var _ref;
      this.completed = false;
      if ((_ref = this.levelIndex) == null) {
        this.levelIndex = -1;
      }
      this.levelIndex++;
      if (this.levelIndex >= this.levels.length) {
        this.levelIndex = 0;
      }
      return this.reset();
    };

    Object.defineProperty(Stage.prototype, 'health', {
      get: function() {
        return this._health;
      },
      set: function(val) {
        this._health = val > 0 ? val : 0;
        return $('#health').html(this._health);
      }
    });

    return Stage;

  })();

}).call(this);
